<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Range Helper – Image Overlay</title>
<style>
:root { --bg:#0b1220; --panel:#0f172a; --ink:#e5e7eb; --muted:#a3b2c7; --accent:#38bdf8; }
*{box-sizing:border-box}
body{margin:0;background:linear-gradient(180deg,#0a0f1a,#070d15);color:var(--ink);font:15px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
.wrap{max-width:1100px;margin:24px auto;padding:0 16px}
h1{font-size:26px;margin:0 0 12px}
.flex{display:flex;gap:14px;align-items:stretch;flex-wrap:wrap}
.card{background:var(--panel);border:1px solid #1d2737;border-radius:16px;padding:12px 12px;box-shadow:0 8px 30px rgba(0,0,0,.35)}
.left{flex:1 1 560px;min-width:300px}
.right{flex:1 1 360px;min-width:280px}
label{font-weight:600;color:var(--muted);font-size:13px}
input,select,button{width:100%;padding:10px 12px;border-radius:12px;border:1px solid #223045;background:#0a1422;color:var(--ink)}
input:focus,select:focus{outline:2px solid var(--accent);border-color:transparent}
.row{margin-top:8px}
.row-inline{display:flex;gap:8px}
.btn{cursor:pointer;font-weight:700;background:linear-gradient(180deg,#0ea5e9,#0284c7);border:none}
.btn:active{transform:translateY(1px)}
.muted{color:var(--muted);font-size:12px}
.hr{height:1px;background:#1f2b3e;margin:10px 0}
canvas{display:block;width:100%;height:auto;background:#000;border-radius:14px;border:1px solid #1f2b3e;touch-action:none}

.legend{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.dot{width:10px;height:10px;border-radius:50%}
.pill{display:inline-block;padding:.2rem .55rem;border-radius:999px;background:#0b1320;border:1px solid #243144;font-size:12px}
.ok{background:#08331f;border-color:#0f5132;color:#8ff0b3}
.warn{background:#331f08;border-color:#7a4d1b;color:#ffcf8b}
.err{background:#3a0a10;border-color:#7a1b28;color:#ffc0ca}
.grid{display:grid;gap:8px;grid-template-columns:1fr}
@media (min-width:720px){ .grid{grid-template-columns:1fr 1fr} }
  /* Scorecard */
.scorecard h2{margin:0 0 8px;font-size:16px}
.scorecard table{width:100%;border-collapse:collapse;font-size:13px}
.scorecard th,.scorecard td{border:1px solid #243144;padding:6px 8px;text-align:center}
.scorecard th{background:#0b1320;color:#cbd5e1;font-weight:700}
.scorecard .subhead th{background:#0a1422;color:#a3b2c7}
.scorecard input[type="number"]{
  width:58px;padding:6px 8px;border-radius:10px;border:1px solid #223045;background:#0a1422;color:var(--ink);
  text-align:center;font-size:13px
}
.scorecard .totals td{font-weight:700;background:#0b1320}
.scorecard .pill-mini{display:inline-block;padding:2px 8px;border:1px solid #243144;border-radius:999px;font-size:12px}
.scorecard .ok{color:#8ff0b3;border-color:#0f5132}
/* Responsive: stack Course/Hole/Next Hole vertically on narrow screens */
@media (max-width: 640px) {
  .row-inline[style*="justify-content:space-between;"] {
    flex-direction: column;
    align-items: stretch !important;
  }
  .row-inline[style*="justify-content:space-between;"] > div,
  .row-inline[style*="justify-content:space-between;"] > button {
    flex: none !important;
    width: 100% !important;
  }
  #nextHoleBtn {
    margin-top: 6px;
  }
}
  @media (max-width: 720px){
  .scorecard table{
    display:block;
    overflow-x:auto;
    white-space:nowrap;
  }
}
.pill-mini.ok {
  background-color: rgba(34, 197, 94, 0.15); /* soft green background */
  color: #22c55e; /* subtle green text */
}

.pill-mini.bad {
  background-color: rgba(239, 68, 68, 0.15); /* soft red background */
  color: #ef4444; /* subtle red text */
}
/* --- Load Menu Modal --- */
#modalBackdrop {
  position: fixed; inset: 0; background: rgba(3,10,20,0.55);
  display: none; align-items: center; justify-content: center; z-index: 9999;
}
#loadModal {
  width: min(520px, 92vw);
  background: var(--panel);
  border: 1px solid #243144;
  border-radius: 16px;
  box-shadow: 0 18px 60px rgba(0,0,0,.45);
  padding: 12px;
  color: var(--ink);
}
#loadModal h3 {
  margin: 0 0 8px; font-size: 16px;
}
#loadList {
  margin: 8px 0 0; padding: 0; list-style: none; max-height: 300px; overflow: auto;
  border: 1px solid #1f2b3e; border-radius: 12px;
}
#loadList li + li { border-top: 1px solid #1f2b3e; }
.loadItem {
  width: 100%; text-align: left; background: #0a1422; border: none; color: var(--ink);
  padding: 10px 12px; cursor: pointer; display: flex; gap: 8px; align-items: center;
}
.loadItem:hover { background: #0b132a; }
.loadMeta { color: var(--muted); font-size: 12px; margin-left: auto; white-space: nowrap; }
#modalActions { display:flex; gap:8px; margin-top:10px }
#closeLoad, #deleteLoad {
  flex:1; padding:10px 12px; border-radius:12px; border:1px solid #223045; background:#0a1422; color:var(--ink); cursor:pointer;
}
#deleteLoad { border-color:#57222a; background:#2a0f13; color:#ffc0ca }
/* Load modal search */
#loadSearch {
  width: 100%;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid #223045;
  background: #0a1422;
  color: var(--ink);
  margin: 6px 0 10px;
}
#loadSearch:focus { outline: 2px solid var(--accent); border-color: transparent; }
/* --- Confirm Modal --- */
#confirmBackdrop {
  position: fixed; inset: 0;
  background: rgba(3,10,20,0.55);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 10000;
}
#confirmModal {
  width: min(420px, 90vw);
  background: var(--panel);
  border: 1px solid #243144;
  border-radius: 16px;
  box-shadow: 0 18px 60px rgba(0,0,0,.45);
  padding: 18px;
  color: var(--ink);
  text-align: center;
}
#confirmModal p { margin: 10px 0 18px; }
#confirmModal button {
  padding: 10px 14px;
  border-radius: 10px;
  border: 1px solid #223045;
  background: #0a1422;
  color: var(--ink);
  cursor: pointer;
  min-width: 100px;
}
#confirmModal button:hover { background:#0b1629; }
#confirmCancel { margin-right:10px; }
#confirmOk {
  background: linear-gradient(180deg,#ef4444,#b91c1c);
  border-color:#5c1a1f;
}
/* --- Save Menu Modal --- */
#saveBackdrop {
  position: fixed; inset: 0; background: rgba(3,10,20,0.55);
  display: none; align-items: center; justify-content: center; z-index: 9999;
}
#saveModal {
  width: min(520px, 92vw);
  background: var(--panel);
  border: 1px solid #243144;
  border-radius: 16px;
  box-shadow: 0 18px 60px rgba(0,0,0,.45);
  padding: 12px;
  color: var(--ink);
}
#saveModal h3 { margin: 0 0 8px; font-size: 16px; }
#saveName {
  width: 100%;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid #223045;
  background: #0a1422;
  color: var(--ink);
  margin: 6px 0 10px;
}
#saveName:focus { outline: 2px solid var(--accent); border-color: transparent; }
#saveActions { display:flex; gap:8px; margin-top:10px }
#cancelSave, #confirmSave {
  flex:1; padding:10px 12px; border-radius:12px; border:1px solid #223045; background:#0a1422; color:var(--ink); cursor:pointer;
}
#confirmSave { background: linear-gradient(180deg,#0ea5e9,#0284c7); border:none; font-weight:700; }
/* --- Delete Confirm Modal --- */
#confirmBackdrop {
  position: fixed; inset: 0; background: rgba(3,10,20,0.55);
  display: none; align-items: center; justify-content: center; z-index: 9999;
}
#confirmModal {
  width: min(520px, 92vw);
  background: var(--panel);
  border: 1px solid #243144;
  border-radius: 16px;
  box-shadow: 0 18px 60px rgba(0,0,0,.45);
  padding: 12px;
  color: var(--ink);
}
#confirmModal h3 { margin: 0 0 8px; font-size: 16px; }
#confirmName {
  display:block;
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid #243144;
  background:#0a1422;
  color: var(--ink);
  margin: 6px 0 10px;
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}
#confirmHint { color: #ffc0ca; font-size: 12px; margin-top: 2px; }
#confirmActions { display:flex; gap:8px; margin-top:10px }
#cancelDelete, #confirmDelete {
  flex:1; padding:10px 12px; border-radius:12px; cursor:pointer;
  border:1px solid #223045; background:#0a1422; color:var(--ink);
}
#confirmDelete {
  background:#2a0f13; border-color:#57222a; color:#ffc0ca; font-weight:700;
}

</style>
</head>
<body>
<div class="wrap">
  <h1>Range Helper – Overlay on Course Image</h1>

  <div class="flex">
    <!-- Canvas/Image side -->
    <div class="left card">
   <!-- Course / Hole controls (tidied layout) -->
<div class="row">
  <div class="row-inline" style="gap:8px; align-items:flex-end; justify-content:space-between;">
    <div style="flex:1.2">
      <label>Course</label>
      <select id="courseSelect" style="width:100%; height:38px; font-size:0.95em;">
        <option value="">– Select course –</option>
      </select>
    </div>

    <div style="flex:0.8">
      <label>Hole</label>
      <select id="holeSelect" disabled style="width:100%; height:38px; font-size:0.95em;">
        <option value="">–</option>
      </select>
    </div>

    <div style="flex:0.9; text-align:right;">
      <button id="nextHoleBtn" class="btn" type="button"
        style="height:38px; font-size:0.9em; padding:0 14px; white-space:nowrap;">
        Next Hole ▶
      </button>
    </div>
  </div>
</div>



      <div class="row legend">
        <span class="pill">Click to set: <b id="clickStatus">TEE</b> → <b>PIN</b> → <b>TARGET LINE</b></span>

        <span class="pill">Right-of-line points draw “downward” on the image.</span>
      </div>

      <div class="row">
        <canvas id="cv" width="1024" height="640" title="Click to place Tee then Pin"></canvas>
      </div>

      <div class="row legend">
        <div class="dot" style="background:#22c55e"></div><span class="muted">Tee</span>
        <div class="dot" style="background:#f59e0b"></div><span class="muted">Pin</span>
        <div class="dot" style="background:#ef4444"></div><span class="muted">Landing</span>
        <div class="dot" style="background:#38bdf8"></div><span class="muted">Perp “Right” axis</span>
      </div>

      <div class="row row-inline">
        <button class="btn" id="undoBtn" style="flex:1" type="button">Undo last shot</button>
        <button class="btn" id="clearBtn" style="flex:1;background:linear-gradient(180deg,#ef4444,#b91c1c)" type="button">Clear all</button>
      </div>
    </div>

    <!-- Controls/result side -->
    <div class="right card">
      <div class="grid">
       

        <div class="row">
     



          <label>Hole / Target distance (yards)</label>
          <input id="holeYards" type="number" value="350" min="1" step="1">
        </div>
        <div class="row">
          <label>Total shot distance (yards)</label>
          <input id="totalYards" type="number" placeholder="e.g. 265" min="1" step="0.1">
        </div>

        <div class="row">
  <label>Club used</label>
  <div class="row-inline">
    <select id="clubSelect" style="flex:1">
      <option value="">Select club (optional)</option>
      <option value="Driver">Driver</option>
      <option value="3W">3 Wood</option>
      <option value="5W">5 Wood</option>
      <option value="7W">7 Wood</option>
      <option value="9W">9 Wood</option>
      <option value="3H">3 Hybrid</option>
      <option value="4H">4 Hybrid</option>
      <option value="5H">5 Hybrid</option>
      <option value="4I">4 Iron</option>
      <option value="5I">5 Iron</option>
      <option value="6I">6 Iron</option>
      <option value="7I">7 Iron</option>
      <option value="8I">8 Iron</option>
      <option value="9I">9 Iron</option>
      <option value="PW">Pitching Wedge</option>
      <option value="AW">Gap Wedge</option>
      <option value="SW">Sand Wedge</option>
      <option value="LW">Lob Wedge</option>
    </select>
    <span class="muted" style="align-self:center;white-space:nowrap;">)</span>
  </div>

  <!-- Keep the original angle inputs hidden so existing math/code keeps working -->
  <div style="display:none">
    <input id="angleDeg" type="number" step="0.1" value="">
    <select id="angleSide">
      <option value="R" selected>Right (+)</option>
      <option value="L">Left (−)</option>
    </select>
  </div>
</div>

        <div class="row">
          <label>Finished lateral from target line (meters)</label>
          <div class="row-inline">
            <input id="finishLatM" type="number" step="0.1" placeholder="e.g. 18" style="flex:2">
            <select id="finishSide" style="flex:1">
              <option value="R">Right</option>
              <option value="L">Left</option>
            </select>
          </div>
          <div class="muted">If set, this overrides the angle for drawing.</div>
        </div>
      </div>

      <div class="row">
        <button class="btn" id="calcBtn" type="button">Plot Shot on Image</button>
      </div>

      <div class="hr"></div>
     <div id="out"></div>
<div class="hr"></div>
<div id="shotList"></div>

    </div>
  </div>

  <!-- Scorecard full-width under the two panels -->
  <div id="scorecard" class="card" style="margin-top:14px"></div>


  <p class="muted" style="margin-top:10px">
  
  </p>
</div>

<script>
(function(){
  // ---------- helpers ----------
  const yd2m = 0.9144, m2yd = 1/yd2m;
  const $ = (id)=>document.getElementById(id);
  const fmt = (n,d=1)=>Number.isFinite(n)?n.toFixed(d):'—';
  const out = $('out');
  // ===== CSV CONFIG =====
const CSV_URL   = 'https://raw.githubusercontent.com/lexington1988/drange/main/Courses.csv';
const IMAGE_BASE = 'https://raw.githubusercontent.com/lexington1988/drange/main/';


// Data model for all rows in the CSV:
// [{ course:'Six Hills (Front 9)', hole:1, par:4, yards:398, image:'./six-hills/hole-01.jpg' }, ...]
let courseRows = [];
let currentCourse = '';
let currentHoleIndex = 0; // index within filtered rows for the selected course

const courseSelect = $('courseSelect');
const holeSelect   = $('holeSelect');
const nextHoleBtn  = $('nextHoleBtn');
// --- Simple CSV parser (no quoted commas in this dataset) ---
function parseCSV(text) {
  const lines = text.split(/\r?\n/).filter(l => l.trim().length);
  if (!lines.length) return [];
  const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
  return lines.slice(1).map(line => {
    const cells = line.split(',').map(c => c.trim());
    const obj = {};
    headers.forEach((h, i) => obj[h] = cells[i] ?? '');
    // normalize types
    obj.hole  = +obj.hole || 0;
    obj.par   = +obj.par || 0;
    obj.yards = +obj.yards || 0;
    return obj;
  });
}

// Turn possible relative image path into absolute

// Return unique *base* course names (e.g., "Six Hills"), collapsing "(Front 9)"/"(Back 9)"
function getCourseNames(rows) {
  const seen = new Set();
  const out = [];
  for (const r of rows) {
    const base = baseCourseName(r.course || '');
    if (base && !seen.has(base)) { seen.add(base); out.push(base); }
  }
  return out;
}


function rowsForCourse(name) {
  const base = baseCourseName(name || '');
  const rows = courseRows
    .filter(r => baseCourseName(r.course || '') === base)
    .map(r => {
      // Make a shallow copy and normalize the hole number
      const copy = { ...r };
      let h = Number(copy.hole) || 0;

      // If CSV labels "(Back 9)" but numbers 1..9, offset to 10..18
      if (/\(Back\s*9\)/i.test(copy.course || '') && h >= 1 && h <= 9) {
        h = 9 + h; // 1→10 ... 9→18
      }
      copy.hole = h;
      return copy;
    })
    .sort((a,b)=>a.hole - b.hole);

  return rows;
}

function baseCourseName(name){
  if (!name) return '';
  return name.replace(/\s*\((Front|Back)\s*9\)\s*$/i,'').trim();
}

/**
 * Pre-fill score[].par for the selected course, including BOTH nines.
 * - Works whether the CSV numbers the back nine as 10–18 OR as 1–9.
 * - If it’s 1–9 on "(Back 9)", we offset those to holes 10–18.
 */
  function slugifyCourseName(name){
  return baseCourseName(name)
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

function resolveImagePath(row){
  let p = (row.image || '').trim();
  if (!p) return '';
  if (/^https?:\/\//i.test(p)) return p; // already a full URL

  // normalize leading ./ or /
  p = p.replace(/^\.\//, '').replace(/^\/+/, '');

  // If path doesn’t start with 'courses/', add it.
  // If there’s no slash at all (just a filename), inject the course slug folder.
  if (!/^courses\//i.test(p)) {
    if (!p.includes('/')) {
      const slug = slugifyCourseName(row.course || '');
      p = `courses/${slug}/${p}`;
    } else {
      p = `courses/${p}`;
    }
  }

  // Build a raw.githubusercontent URL
  return `https://raw.githubusercontent.com/lexington1988/drange/main/${p}`;
}

function preloadAllParsForCourse(selectedCourse){
  // reset to a sensible default first
  for (let i = 0; i < score.length; i++) score[i].par = 4;

  const base = baseCourseName(selectedCourse);
  const rows = courseRows
    .filter(r => baseCourseName(r.course) === base)
    .sort((a,b)=>a.hole - b.hole);

  for (const r of rows){
    let idx = (r.hole|0) - 1;

    // If the CSV splits the course and numbers back-nine as 1..9, push them to 10..18
    if (/\(Back\s*9\)/i.test(r.course) && r.hole >= 1 && r.hole <= 9) {
      idx = 9 + (r.hole - 1);
    }

    // If the CSV already uses 10..18, the idx above is already correct.

    if (idx >= 0 && idx < score.length){
      score[idx].par = +r.par || score[idx].par;
    }
  }
  renderScorecard();
}


function fillCourseMenu() {
  courseSelect.innerHTML = '<option value="">– Select course –</option>';
  const bases = getCourseNames(courseRows); // now returns "Six Hills" (once)
  for (const c of bases) {
    const opt = document.createElement('option');
    opt.value = c; opt.textContent = c;
    courseSelect.appendChild(opt);
  }
}


function fillHoleMenu(courseName) {
  const rows = rowsForCourse(courseName); // now returns both nines
  holeSelect.innerHTML = '';
  for (const r of rows) {
    const opt = document.createElement('option');
    opt.value = String(r.hole);
    opt.textContent = `Hole ${r.hole}`;
    holeSelect.appendChild(opt);
  }
  holeSelect.disabled = rows.length === 0;
}


// Load selected hole: set image, yards, and par
function applyHoleByIndex(courseName, index) {
  const rows = rowsForCourse(courseName);
  if (!rows.length) return;

  // clamp index
  currentHoleIndex = Math.max(0, Math.min(index, rows.length - 1));
  const row = rows[currentHoleIndex];

  // UI selects
  courseSelect.value = courseName;
  holeSelect.value = String(row.hole);

  // Set hole distance (yards) input
  $('holeYards').value = row.yards || '';

// --- Update par + hole label + scroll ---
if (typeof score !== 'undefined' && Array.isArray(score)) {
  const idx = row.hole - 1;
  if (idx >= 0 && idx < score.length) {
    score[idx].par = row.par || 4;
  }
  renderScorecard();
}

// Update hole label (for clarity on right panel)
let holeLabel = document.getElementById('holeLabel');
if (!holeLabel) {
  // If label doesn’t exist yet, create it above the holeYards input
  const labelRow = document.querySelector('label[for="holeYards"]')?.parentElement;
  if (labelRow) {
    holeLabel = document.createElement('div');
    holeLabel.id = 'holeLabel';
    holeLabel.className = 'muted';
    holeLabel.style.marginBottom = '4px';
    labelRow.insertBefore(holeLabel, labelRow.firstChild);
  }
}
if (holeLabel) {
  holeLabel.textContent = `Hole ${row.hole} (${row.par || '-'} par)`;
}

// Also update the yardage box correctly
const holeYardsInput = document.getElementById('holeYards');
if (holeYardsInput) {
  holeYardsInput.value = row.yards || '';
}

randomizeWind(); // new wind each time a hole is applied

// Scroll to top of canvas smoothly (so user always sees new hole)
document.querySelector('canvas')?.scrollIntoView({ behavior: 'smooth' });


  // Load the hole image onto the canvas
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = () => {
    baseImg = img;

    // Fit canvas to image with sane max size (same as your upload flow)
    const maxW = 1024, maxH = 768;
    let w = img.width, h = img.height;
    const scale = Math.min(maxW / w, maxH / h, 1);
    cv.width  = Math.round(w * scale);
    cv.height = Math.round(h * scale);

    // reset view and markers/shots
    view.scale = 1; view.tx = 0; view.ty = 0;
    tee = pin = target = null;
    shots.length = 0;
    shotIndex = 0;
    clickStatus.textContent = 'TEE';
    clearOut();
    renderShotList();

    redraw();
  };
  img.onerror = () => {
    clearOut();
    line('Could not load hole image from CSV path.', 'err');
  };
  img.src = resolveImagePath(row);

}

// Next hole (wraps to start of the same course)
function goToNextHole() {
  if (!currentCourse) return;
  const rows = rowsForCourse(currentCourse);
  if (!rows.length) return;
  const nextIdx = (currentHoleIndex + 1) % rows.length;
  applyHoleByIndex(currentCourse, nextIdx); // applyHoleByIndex will randomize wind
}




  function line(html, cls){
    const p=document.createElement('div');
    if(cls) p.className = cls;
    p.innerHTML=html;
    out.appendChild(p);
  }
  function clearOut(){ out.innerHTML=''; }
function renderShotList(){
  const wrap = $('shotList');
  if(!wrap) return;
  wrap.innerHTML = '';

  shots.forEach((s,i)=>{
    const lrText = `${fmt(Math.abs(s.leftRightYd||0),1)} yd ${s.leftRightYd<0?'Left':s.leftRightYd>0?'Right':'(online)'}`;
    const slText = s.shortLongYd>=0
      ? `${fmt(s.shortLongYd,1)} yd short`
      : `${fmt(-s.shortLongYd,1)} yd long`;
    const clubColor = getClubGroupColor(s.club) || '#a3b2c7';
    const clubTag = s.club ? `<span class="pill" style="margin-left:6px;border-color:${clubColor};color:${clubColor}">${s.club}</span>` : '';

    const card = document.createElement('div');
    card.className = 'card';
    card.style.padding = '8px 10px';
    card.style.marginBottom = '8px';
    card.innerHTML = `
      <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
        <div><b>#${i+1}</b> ${clubTag}</div>
        <button class="btn delShot" data-idx="${i}" type="button"
          style="padding:6px 10px;border-radius:8px;font-size:12px;background:linear-gradient(180deg,#ef4444,#b91c1c)">
          Delete
        </button>
      </div>
      <div class="muted" style="margin-top:6px">
        Total: <b>${fmt(s.totalYards||0,1)} yd</b>
        &nbsp;|&nbsp;
        To pin: <b style="color:${(s.distToPinYd||0)<=10?'#22c55e':'#ef4444'}">${fmt(s.distToPinYd||0,1)} yd</b>
      </div>
      <div class="muted">
        Short/Long: <b>${slText}</b>
        &nbsp;|&nbsp;
        Left/Right: <b>${lrText}</b>
      </div>
    `;
    wrap.appendChild(card);
  });

  // Event delegation for per-shot delete
  wrap.onclick = (e)=>{
    const btn = e.target.closest('.delShot');
    if(!btn) return;
    const idx = parseInt(btn.dataset.idx,10);
    if(Number.isInteger(idx)){
      shots.splice(idx,1);
      redraw();
      renderShotList();
    }
  };
}


// ---------------- Scorecard ----------------
const score = Array.from({length:18},()=>({par:4, strokes:''}));
 // --- Local storage helpers for scorecards ---
const LS_KEY_CURRENT = 'rh:scorecard:current';
const LS_KEY_ALL     = 'rh:scorecards';

function saveCurrentScorecard(){
  try {
    localStorage.setItem(LS_KEY_CURRENT, JSON.stringify(score));
  } catch(e) { /* ignore quota errors */ }
}

function loadCurrentScorecardIfAny(){
  try {
    const raw = localStorage.getItem(LS_KEY_CURRENT);
    if (!raw) return false;
    const arr = JSON.parse(raw);
    if (!Array.isArray(arr) || arr.length !== 18) return false;
    for (let i=0;i<18;i++){
      const s = arr[i] || {};
      score[i].par     = Number.isFinite(+s.par) ? +s.par : 4;
      score[i].strokes = (s.strokes === '' ? '' : Math.max(0, Math.floor(+s.strokes||0)));
    }
    return true;
  } catch(e){ return false; }
}

// Named saves to keep MULTIPLE scorecards
function getAllSavedScorecards(){
  try {
    const raw = localStorage.getItem(LS_KEY_ALL);
    const map = raw ? JSON.parse(raw) : {};
    return (map && typeof map === 'object') ? map : {};
  } catch { return {}; }
}

function saveNamedScorecard(name){
  const map = getAllSavedScorecards();
  map[name] = {
    when: new Date().toISOString(),
    course: currentCourse || '',
    score: JSON.parse(JSON.stringify(score)) // deep-ish copy
  };
  try { localStorage.setItem(LS_KEY_ALL, JSON.stringify(map)); } catch {}
}

function loadNamedScorecard(name){
  const map = getAllSavedScorecards();
  const entry = map[name];
  if (!entry || !Array.isArray(entry.score) || entry.score.length !== 18) return false;
  for (let i=0;i<18;i++){
    const s = entry.score[i] || {};
    score[i].par     = Number.isFinite(+s.par) ? +s.par : 4;
    score[i].strokes = (s.strokes === '' ? '' : Math.max(0, Math.floor(+s.strokes||0)));
  }
  return true;
}
// --- Clickable Load Menu (modal) ---
function ensureLoadModal(){
  if (document.getElementById('modalBackdrop')) return;
  const wrap = document.createElement('div');
  wrap.id = 'modalBackdrop';
  wrap.innerHTML = `
    <div id="loadModal" class="card">
      <h3>Select a saved scorecard</h3>
      <input id="loadSearch" type="search" placeholder="Search by name or course…">
      <ul id="loadList"></ul>
      <div id="modalActions">
        <button id="closeLoad">Close</button>
        <button id="deleteLoad" title="Delete selected (asks for confirmation)">Delete</button>
      </div>
    </div>
  `;
  document.body.appendChild(wrap);

  // Close on backdrop click
  wrap.addEventListener('click', (e)=>{
    if (e.target === wrap) wrap.style.display = 'none';
  });
  // Close button
  document.getElementById('closeLoad').onclick = ()=> wrap.style.display = 'none';

  // Delete selected (we store selected name on #loadModal dataset)
  document.getElementById('deleteLoad').onclick = ()=>{
  const modal = document.getElementById('loadModal');
  const name = modal?.dataset?.selected || '';
  if (!name) return;

  openDeleteModal(name, ()=> {
    const map = getAllSavedScorecards();
    delete map[name];
    try { localStorage.setItem('rh:scorecards', JSON.stringify(map)); } catch {}
    // refresh list
    populateLoadList(document.getElementById('loadSearch')?.value || '');
    // clear selected
    modal.dataset.selected = '';
  });
};


  // Search input → filter list live
  const search = document.getElementById('loadSearch');
  if (search){
    search.addEventListener('input', ()=>{
      const q = search.value || '';
      populateLoadList(q);
    });
  }
}
// --- Custom in-app confirm modal (returns a Promise<boolean>) ---
function confirmModal(message){
  return new Promise(resolve=>{
    // Build once
    let wrap = document.getElementById('confirmBackdrop');
    if(!wrap){
      wrap = document.createElement('div');
      wrap.id = 'confirmBackdrop';
      wrap.innerHTML = `
        <div id="confirmModal" class="card">
          <p id="confirmMsg"></p>
          <div>
            <button id="confirmCancel">Cancel</button>
            <button id="confirmOk">OK</button>
          </div>
        </div>`;
      document.body.appendChild(wrap);
    }
    const msg = document.getElementById('confirmMsg');
    msg.textContent = message;
    wrap.style.display = 'flex';

    const cancel = document.getElementById('confirmCancel');
    const ok = document.getElementById('confirmOk');
    const close = (result)=>{
      wrap.style.display='none';
      cancel.onclick = ok.onclick = null;
      resolve(result);
    };
    cancel.onclick = ()=> close(false);
    ok.onclick = ()=> close(true);
  });
}
// --- Save Menu (modal) ---
function ensureSaveModal(){
  if (document.getElementById('saveBackdrop')) return;

  const wrap = document.createElement('div');
  wrap.id = 'saveBackdrop';
  wrap.innerHTML = `
    <div id="saveModal" class="card">
      <h3>Save scorecard</h3>
      <input id="saveName" type="text" placeholder="Name your scorecard…">
      <div id="saveActions">
        <button id="cancelSave" type="button">Cancel</button>
        <button id="confirmSave" type="button">Save</button>
      </div>
    </div>
  `;
  document.body.appendChild(wrap);

  // Close on backdrop click
  wrap.addEventListener('click', (e)=>{
    if (e.target === wrap) wrap.style.display = 'none';
  });

  document.getElementById('cancelSave').onclick = ()=> {
    wrap.style.display = 'none';
  };

  // Confirm save
  document.getElementById('confirmSave').onclick = ()=> {
    const inp = document.getElementById('saveName');
    const name = (inp.value || '').trim();
    if (!name) return; // do nothing if empty
    saveNamedScorecard(name);
    saveCurrentScorecard();
    wrap.style.display = 'none';
    // brief visual feedback on the main Save button (if present)
    const saveBtn = document.getElementById('saveScore');
    if (saveBtn){
      saveBtn.textContent = 'Saved ✓';
      setTimeout(()=> saveBtn.textContent = 'Save', 1200);
    }
  };

  // Enter to save
  document.getElementById('saveName').addEventListener('keydown', (e)=>{
    if (e.key === 'Enter') {
      document.getElementById('confirmSave').click();
    }
  });
}

function openSaveMenu(defaultName=''){
  ensureSaveModal();
  const wrap = document.getElementById('saveBackdrop');
  const input = document.getElementById('saveName');
  input.value = defaultName || '';
  wrap.style.display = 'flex';
  // focus after visible
  setTimeout(()=> input.focus(), 0);
}
// --- Delete Confirm (modal) ---
function ensureDeleteModal(){
  if (document.getElementById('confirmBackdrop')) return;

  const wrap = document.createElement('div');
  wrap.id = 'confirmBackdrop';
  wrap.innerHTML = `
    <div id="confirmModal" class="card">
      <h3>Delete saved scorecard</h3>
      <div id="confirmName"></div>
      <div id="confirmHint">This cannot be undone.</div>
      <div id="confirmActions">
        <button id="cancelDelete" type="button">Cancel</button>
        <button id="confirmDelete" type="button">Delete</button>
      </div>
    </div>
  `;
  document.body.appendChild(wrap);

  // backdrop click closes
  wrap.addEventListener('click', (e)=>{
    if (e.target === wrap) wrap.style.display = 'none';
  });
}

function openDeleteModal(name, onConfirm){
  ensureDeleteModal();
  const wrap = document.getElementById('confirmBackdrop');
  const nameBox = document.getElementById('confirmName');
  nameBox.textContent = name || '';
  wrap.style.display = 'flex';

  const cancelBtn = document.getElementById('cancelDelete');
  const okBtn     = document.getElementById('confirmDelete');

  // clean previous handlers
  cancelBtn.onclick = ()=> { wrap.style.display = 'none'; };
  okBtn.onclick = ()=> {
    wrap.style.display = 'none';
    if (typeof onConfirm === 'function') onConfirm();
  };
}


function populateLoadList(filterText = ''){
  const list = document.getElementById('loadList');
  if (!list) return;
  list.innerHTML = '';
  const map = getAllSavedScorecards();
  let names = Object.keys(map);

  // Newest first
  names.sort((a,b)=>{
    const da = map[a]?.when ? Date.parse(map[a].when) : 0;
    const db = map[b]?.when ? Date.parse(map[b].when) : 0;
    return db - da;
  });

  // Case-insensitive filter by name or course
  const q = (filterText || '').toLowerCase().trim();
  if (q){
    names = names.filter(n=>{
      const course = (map[n]?.course || '').toLowerCase();
      return n.toLowerCase().includes(q) || course.includes(q);
    });
  }

  // Helper: compute to-par using only played holes (strokes > 0)
  function computeToPar(scoreArr){
    if (!Array.isArray(scoreArr) || scoreArr.length !== 18) return null;
    let stPlayed = 0, parPlayed = 0;
    for (let i = 0; i < 18; i++){
      const s = scoreArr[i] || {};
      const strokes = Number.isFinite(+s.strokes) ? +s.strokes : 0;
      const par = Number.isFinite(+s.par) ? +s.par : 4;
      if (strokes > 0){
        stPlayed += strokes;
        parPlayed += par;
      }
    }
    if (stPlayed === 0) return null;
    return stPlayed - parPlayed; // + over, − under, 0 even
  }

  if (names.length === 0){
    list.innerHTML = `<li><div class="loadItem" style="cursor:default;opacity:.7">No matches</div></li>`;
    return;
  }

  for (const n of names){
    const entry = map[n];
    const when = entry?.when ? new Date(entry.when).toLocaleString() : '';

    // Build the to-par pill (same style as scorecard)
    const toParVal = computeToPar(entry?.score);
    let pillHTML = '';
    if (toParVal !== null){
      const txt = toParVal === 0 ? 'E' : (toParVal > 0 ? `+${toParVal}` : `${toParVal}`);
      const cls = toParVal <= 0 ? 'ok' : 'bad'; // green for E/under, red for over
      pillHTML = `<span class="pill-mini ${cls}" style="margin-left:8px">${txt}</span>`;
    }

    // Left column now: saved name (which already includes date/course) + score pill
    const li = document.createElement('li');
    li.innerHTML = `
      <button class="loadItem" type="button" data-name="${n}">
        <span>${n}${pillHTML}</span>
        <span class="loadMeta">${when}</span>
      </button>`;
    list.appendChild(li);
  }

  // Load on click & mark selected for delete
  list.onclick = (e)=>{
    const btn = e.target.closest('.loadItem');
    if(!btn) return;
    const name = btn.dataset.name;
    const ok = loadNamedScorecard(name);
    if (ok) {
      saveCurrentScorecard();
      renderScorecard();
      document.getElementById('modalBackdrop').style.display = 'none';
    }
    const modal = document.getElementById('loadModal');
    if (modal) modal.dataset.selected = name;
  };
}




function openLoadMenu(){
  ensureLoadModal();
  populateLoadList();
  document.getElementById('modalBackdrop').style.display = 'flex';
}

const strokesStore = {};
function saveStrokesForCourseBase(name){
  if(!name) return;
  const key = baseCourseName(name);
  strokesStore[key] = score.map(s => (s.strokes === '' ? '' : Math.max(0, Math.floor(+s.strokes||0))));
}
function restoreStrokesForCourseBase(name){
  if(!name) return;
  const key = baseCourseName(name);
  const arr = strokesStore[key];
  if(!arr) return;
  for(let i=0;i<score.length;i++){
    const v = arr[i];
    score[i].strokes = (v === '' ? '' : Math.max(0, Math.floor(+v||0)));
  }
}

// Preload the full Par row on the scorecard from the selected course
function preloadCoursePars(courseName){
  const rows = rowsForCourse(courseName);
  // Reset all to a sensible default first
  for (let i = 0; i < score.length; i++) {
    score[i].par = 4;
  }
  // Apply CSV pars by hole number
  for (const r of rows) {
    const idx = (r.hole || 0) - 1;
    if (idx >= 0 && idx < score.length) {
      score[idx].par = r.par || 4;
    }
  }
  // Re-render so the scorecard shows pars immediately
  renderScorecard();
}

function renderScorecard(){
  const el = $('scorecard');
  if(!el) return;

  const holesHeader = (start)=>Array.from({length:9},(_,i)=>`<th>${start+i}</th>`).join('');
  const holesInputs = (field, start)=>Array.from({length:9},(_,i)=>{
    const idx = start-1+i;
    const val = score[idx][field];
    return `<td><input type="number" inputmode="numeric" pattern="[0-9]*"
              data-idx="${idx}" data-field="${field}" value="${val === '' ? '' : val}" min="0" step="1"></td>`;
  }).join('');

  // A hole is "played" if strokes > 0
  const played = score.map(s => Number.isFinite(+s.strokes) && +s.strokes > 0);

  function sumRange(arr, start, count, field, onlyPlayed = false) {
    let t = 0;
    for (let i = 0; i < count; i++) {
      const idx = start + i;
      if (onlyPlayed && !played[idx]) continue;
      const v = +arr[idx][field];
      if (!Number.isFinite(v)) continue;
      if (field === 'strokes' ? v > 0 : true) t += v;
    }
    return t;
  }

  // Course par rows (always full nine values)
  const parOutCourse = sumRange(score, 0, 9, 'par', false);
  const parInCourse  = sumRange(score, 9, 9, 'par', false);
  const parCourseTot = parOutCourse + parInCourse;

  // Strokes only for played holes
  const stOutPlayed = sumRange(score, 0, 9, 'strokes', true);
  const stInPlayed  = sumRange(score, 9, 9, 'strokes', true);
  const stPlayedTot = stOutPlayed + stInPlayed;

  // Par for played holes (the correct to-par basis)
  const parOutPlayed = sumRange(score, 0, 9, 'par', true);
  const parInPlayed  = sumRange(score, 9, 9, 'par', true);
  const parPlayedTot = parOutPlayed + parInPlayed;

  const toPar    = stPlayedTot > 0 ? (stPlayedTot - parPlayedTot) : 0;
  const toParTxt = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : `${toPar}`);
  const toParCls = toPar <= 0 ? 'ok' : 'bad';

  el.innerHTML = `
    <div class="scorecard">
      <h2>Scorecard <span class="pill-mini ${toParCls}" title="Relative to par for holes played">${toParTxt}</span></h2>
      <table>
        <tr class="subhead"><th></th>${holesHeader(1)}<th>Out</th></tr>
        <tr><th>Par</th>${holesInputs('par',1)}<td>${parOutCourse}</td></tr>
        <tr><th>Strokes</th>${holesInputs('strokes',1)}<td>${stOutPlayed || ''}</td></tr>

        <tr class="subhead"><th></th>${holesHeader(10)}<th>In</th></tr>
        <tr><th>Par</th>${holesInputs('par',10)}<td>${parInCourse}</td></tr>
        <tr><th>Strokes</th>${holesInputs('strokes',10)}<td>${stInPlayed || ''}</td></tr>

        <tr class="totals"><td><b>Total</b></td>
          <td colspan="9">${parOutCourse + (stOutPlayed ? ` / ${stOutPlayed}` : '')}</td>
          <td colspan="9">${parInCourse + (stInPlayed  ? ` / ${stInPlayed}`  : '')}</td>
        </tr>
        <tr class="totals"><td><b>Grand</b></td>
          <td colspan="18">
            Par ${parCourseTot}${stPlayedTot ? ` / Strokes ${stPlayedTot} (${toParTxt})` : ''}
          </td>
        </tr>
      </table>
      <div class="row row-inline" style="margin-top:8px">
        <button class="btn" id="resetScore" type="button" style="flex:1;background:linear-gradient(180deg,#ef4444,#b91c1c)">Clear scorecard</button>
        <button class="btn" id="saveScore"  type="button" style="flex:1">Save</button>
        <button class="btn" id="loadScore"  type="button" style="flex:1;background:linear-gradient(180deg,#0ea5e9,#0284c7)">Load</button>
      </div>
    </div>
  `;

  // Input change handler (auto-save current)
  el.querySelectorAll('input[data-idx]').forEach(inp=>{
    inp.addEventListener('input', ()=>{
      const idx = +inp.dataset.idx;
      const field = inp.dataset.field;
      const v = inp.value === '' ? '' : Math.max(0, Math.floor(+inp.value||0));
      score[idx][field] = v;
      saveCurrentScorecard();
      renderScorecard();
    });
  });

 // Clear strokes only (preserve pars) using custom modal
const resetBtn = $('resetScore');
if (resetBtn){
  resetBtn.onclick = async ()=>{
    const ok = await confirmModal('Are you sure you want to clear all entered strokes?');
    if (!ok) return;
    for (let i = 0; i < 18; i++){
      score[i].strokes = '';
    }
    saveCurrentScorecard();
    renderScorecard();
  };
}




// Save named snapshot (for multiple scorecards) — themed modal
const saveBtn = $('saveScore');
if (saveBtn){
  saveBtn.onclick = ()=>{
    const when = new Date();
    const defaultName = `${when.toLocaleDateString()} ${currentCourse || ''}`.trim();
    openSaveMenu(defaultName);
  };
}


// Load from a named snapshot (clickable modal)
const loadBtn = $('loadScore');
if (loadBtn){
  loadBtn.onclick = ()=> openLoadMenu();
}

}



// Initial render once the DOM exists (+ try loading saved session)
renderScorecard();
if (loadCurrentScorecardIfAny()) renderScorecard();

// ===== Fetch CSV and build menus =====
async function initCourses() {
  try {
    const res = await fetch(CSV_URL, { cache: 'no-store' });
    const txt = await res.text();
    courseRows = parseCSV(txt);

    fillCourseMenu();

    // Optional: auto-select the first course & first hole on load
  const firstCourse = getCourseNames(courseRows)[0];
if (firstCourse) {
  currentCourse = firstCourse;
fillHoleMenu(currentCourse);
preloadAllParsForCourse(currentCourse);   // ensure both 9s populate
applyHoleByIndex(currentCourse, 0);

}


  } catch (e) {
    line('Could not load Courses CSV. Check the URL and CORS.', 'err');
    console.error(e);
  }
}

courseSelect?.addEventListener('change', () => {
  currentCourse = courseSelect.value;
  if (!currentCourse) {
    holeSelect.innerHTML = '<option value="">–</option>';
    holeSelect.disabled = true;
    for (let i = 0; i < score.length; i++) score[i].par = 4;
    renderScorecard();
    return;
  }
  fillHoleMenu(currentCourse);
  preloadAllParsForCourse(currentCourse);
  applyHoleByIndex(currentCourse, 0); // this will randomize wind for the first hole
});




holeSelect?.addEventListener('change', () => {
  if (!currentCourse) return;
  const rows = rowsForCourse(currentCourse);
  const idx = rows.findIndex(r => String(r.hole) === holeSelect.value);
  if (idx >= 0) applyHoleByIndex(currentCourse, idx);
});

nextHoleBtn?.addEventListener('click', goToNextHole);

// Kick off CSV load
initCourses();

  // ---------- canvas & image ----------
  const cv = $('cv');
  const ctx = cv.getContext('2d');

// --- animation loop for the dashed target line ---
// This runs every frame. We only advance the dash when a target line was drawn.
function animate(){
  if (hasTargetLine) {
    targetDashOffset = (targetDashOffset +0.3) % 1000; // tweak 0.8 for faster/slower scan
  }
  hasTargetLine = false;   // redraw will set it back to true if a target line exists
  redraw();
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

  const imgInput = $('imgInput');
  const clickStatus = $('clickStatus');
  const shots = []; // keep plotted shots for redraw/undo
  let baseImg = null;
  let tee = null, pin = null, target = null; // current drawing (third click = target line point)

  // color cycle for shots
  const shotColors = ['#ef4444','#f59e0b','#22c55e','#38bdf8','#a78bfa','#e879f9','#14b8a6','#fb7185'];
  let shotIndex = 0;

// --- Wind state (randomized per hole) ---
let windSpeed = 0;       // mph
let windFromDeg = 0;     // 0=N, 90=E, etc.

function randomizeWind(){
  // Speed: 2–20 mph, one decimal
  windSpeed = +(2 + Math.random() * 18).toFixed(1);
  // Direction: 0–359° (FROM bearing)
  windFromDeg = Math.floor(Math.random() * 360);
}


// --- Animated target line state ---
let targetDashOffset = 0;   // how far the dash pattern has "scanned"
let hasTargetLine = false;  // set to true inside redraw() when target line is drawn

  // --- View transform (zoom/pan) ---
const view = { scale: 1, tx: 0, ty: 0, min: 0.6, max: 4 };
function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }
function screenToCanvasPoint(clientX, clientY){
  const rect = cv.getBoundingClientRect();
  // screen → canvas pixels (before our transform)
  const xS = (clientX - rect.left) * (cv.width / rect.width);
  const yS = (clientY - rect.top)  * (cv.height/ rect.height);
  // inverse of our transform
  return { x: (xS - view.tx)/view.scale, y: (yS - view.ty)/view.scale };
}

  // --- Grouped colors (Driver / Woods / Irons / Wedges) ---
const GROUP_COLORS = {
  Driver: '#ef4444', // red
  Wood:   '#f59e0b', // amber
  Iron:   '#38bdf8', // sky
  Wedge:  '#14b8a6'  // teal
};
// Return one of: 'Driver' | 'Wood' | 'Iron' | 'Wedge' | null
function clubGroup(club){
  if(!club) return null;
  const c = club.toUpperCase();
  if(c === 'DRIVER') return 'Driver';
  if(/^(\d+)W$/.test(c) || /^(\d+)H$/.test(c)) return 'Wood';   // Woods + Hybrids
  if(/^[4-9]I$/.test(c)) return 'Iron';
  if(/^(PW|AW|SW|LW)$/.test(c)) return 'Wedge';
  return null;
}
function getClubGroupColor(club){
  const grp = clubGroup(club);
  return grp ? GROUP_COLORS[grp] : null;
}
// Colorize the <option> items in the club dropdown to match group colors
function colorizeClubOptions(){
  const sel = $('clubSelect');
  if(!sel) return;
  for (const opt of sel.options) {
    const val = opt.value;
    if(!val) continue; // skip the placeholder
    const col = getClubGroupColor(val);
    // Reset any previous prefix dot
    opt.textContent = opt.textContent.replace(/^([●◉○•]\s)?/, '');
    if(col){
      opt.style.color = col;          // color the option text
      opt.textContent = '● ' + opt.textContent; // add a dot that inherits the color
    } else {
      opt.style.color = ''; // default color
    }
  }
}
colorizeClubOptions();

// Consistent colors per club (used if a club is selected)
const CLUB_COLORS = {
  'Driver':'#ef4444',
  '3W':'#fb7185',
  '5W':'#f59e0b',
  '7W':'#fbbf24',
  '9W':'#fde047',
  '3H':'#a78bfa',
  '4H':'#c084fc',
  '5H':'#e879f9',
  '4I':'#22c55e',
  '5I':'#16a34a',
  '6I':'#10b981',
  '7I':'#38bdf8',
  '8I':'#0ea5e9',
  '9I':'#0284c7',
  'PW':'#14b8a6',
  'AW':'#2dd4bf',
  'SW':'#64748b',
  'LW':'#94a3b8'
};
function getClubColor(club){ return CLUB_COLORS[club] || null; }

 if (imgInput) {
  imgInput.addEventListener('change', (e)=>{
    const file = e.target.files[0];
    if(!file) return;
    const img = new Image();
    img.onload = ()=>{
      baseImg = img;
      const maxW = 1024, maxH = 768;
      const scale = Math.min(maxW / img.width, maxH / img.height, 1);
      cv.width  = Math.round(img.width  * scale);
      cv.height = Math.round(img.height * scale);
      view.scale = 1; view.tx = 0; view.ty = 0;
      redraw();
    };
    img.src = URL.createObjectURL(file);

    // reset markers/shots
    tee = null; pin = null; target = null;
    shots.length = 0;
    shotIndex = 0;
    clickStatus.textContent = 'TEE';
    clearOut();
    renderShotList();
  });
}


  cv.addEventListener('click', (ev)=>{
  if(!baseImg) return;
  const {x, y} = screenToCanvasPoint(ev.clientX, ev.clientY);


  if(!tee){
    tee = {x,y};
    clickStatus.textContent = 'PIN';
  } else if(!pin){
    pin = {x,y};
    clickStatus.textContent = 'TARGET';
  } else if(!target){
    target = {x,y};
    clickStatus.textContent = 'SET';
  } else {
  // If we’ve already hit at least one shot, a click sets a new TARGET for the next shot.
  if (shots.length > 0) {
    target = { x, y };
    clickStatus.textContent = 'TARGET';
  } else {
    // Before any shots, allow moving the nearest of tee/pin/target
    const dT = Math.hypot(x-tee.x,y-tee.y);
    const dP = Math.hypot(x-pin.x,y-pin.y);
    const dG = Math.hypot(x-target.x,y-target.y);
    const min = Math.min(dT,dP,dG);
    if(min===dT)      tee = {x,y};
    else if(min===dP) pin = {x,y};
    else              target = {x,y};
  }
}

  redraw();
});
// --- Mobile-friendly pan & pinch (Pointer Events) ---
let isPanning = false;
let panStart = {sx:0, sy:0, tx:0, ty:0};
const activePointers = new Map();

cv.addEventListener('pointerdown', (e)=>{
  cv.setPointerCapture(e.pointerId);
  activePointers.set(e.pointerId, {sx:e.clientX, sy:e.clientY});
  if(activePointers.size === 1){
    // start pan
    isPanning = true;
    panStart = { sx: e.clientX, sy: e.clientY, tx: view.tx, ty: view.ty };
  }
  e.preventDefault();
});

cv.addEventListener('pointermove', (e)=>{
  if(!activePointers.has(e.pointerId)) return;
  activePointers.set(e.pointerId, {sx:e.clientX, sy:e.clientY});

  if(activePointers.size === 1 && isPanning){
    // single-finger drag → pan
    const dx = e.clientX - panStart.sx;
    const dy = e.clientY - panStart.sy;
    view.tx = panStart.tx + dx;
    view.ty = panStart.ty + dy;
    redraw();
  } else if(activePointers.size >= 2){
    // two-finger pinch → zoom (anchor on midpoint)
    const pts = Array.from(activePointers.values());
    const [p1,p2] = pts;
    const midSx = (p1.sx + p2.sx)/2;
    const midSy = (p1.sy + p2.sy)/2;

    if(!cv.__pinchStart){
      const anchorWorld = screenToCanvasPoint(midSx, midSy);
      cv.__pinchStart = {
        anchorWorld,
        startScreen:{x:midSx, y:midSy},
        startDist: Math.hypot(p2.sx - p1.sx, p2.sy - p1.sy),
        startScale: view.scale
      };
    } else {
      const start = cv.__pinchStart;
      const dist = Math.hypot(p2.sx - p1.sx, p2.sy - p1.sy);
      const newScale = clamp(start.startScale * (dist / start.startDist), view.min, view.max);
      view.scale = newScale;
      // keep anchor world point under current midpoint
      view.tx = midSx - start.anchorWorld.x * view.scale;
      view.ty = midSy - start.anchorWorld.y * view.scale;
      redraw();
    }
  }
  e.preventDefault();
});

cv.addEventListener('pointerup', (e)=>{
  activePointers.delete(e.pointerId);
  cv.releasePointerCapture?.(e.pointerId);
  if(activePointers.size === 0){
    isPanning = false;
    cv.__pinchStart = null;
  } else if(activePointers.size === 1){
    // switch back to pan baseline using the remaining finger
    const [only] = Array.from(activePointers.values());
    panStart = { sx: only.sx, sy: only.sy, tx: view.tx, ty: view.ty };
    cv.__pinchStart = null;
  }
  e.preventDefault();
});

cv.addEventListener('pointercancel', ()=>{
  activePointers.clear();
  isPanning = false;
  cv.__pinchStart = null;
});


  $('undoBtn').addEventListener('click', ()=>{
  shots.pop();
  redraw();
  renderShotList();
});


  $('clearBtn').addEventListener('click', ()=>{
   shots.length = 0;
tee = null;
pin = null;
target = null;
clickStatus.textContent = 'TEE';
clearOut();
redraw();
renderShotList();


  });

  function redraw(){
    // background
ctx.setTransform(1,0,0,1,0,0);              // reset any previous transform
ctx.clearRect(0,0,cv.width,cv.height);
ctx.setTransform(view.scale,0,0,view.scale, view.tx, view.ty); // apply zoom/pan
if(baseImg) ctx.drawImage(baseImg,0,0,cv.width,cv.height);


    // target line & markers
 // Dashed reference line: Tee → Pin (hole) + yard markers along the hole
if(tee && pin){
  const hole = parseFloat($('holeYards').value) || 0;
  const teeToPinPix = Math.hypot(pin.x-tee.x, pin.y-tee.y);
  const pxPerYard = (hole > 0) ? (teeToPinPix / hole) : 0;

  ctx.strokeStyle = '#e2e8f0';
  ctx.lineWidth = 2;
  ctx.setLineDash([8,6]);
  ctx.beginPath();
  ctx.moveTo(tee.x, tee.y);
  ctx.lineTo(pin.x, pin.y);
  ctx.stroke();
  ctx.setLineDash([]);

  // yard markers along the dashed (hole) line
  const exHole = unitVec(tee, pin);
  drawYardMarkers(tee, exHole, pxPerYard, hole, 10, 50);
  /* ----- Compass/Wind overlay (screen-space) ----- */
(() => {
  // Aim = target line if present; otherwise tee→pin (if both exist)
  let aimDeg = NaN;
  if (tee && (target || pin)) {
    const startPt = (shots.length > 0 && target) ? shots[shots.length - 1] : tee;
    const endPt   = target ? target : pin;
    if (startPt && endPt) {
      aimDeg = bearingDeg(startPt.x, startPt.y, endPt.x, endPt.y);
    }
  }
 drawCompassOverlay(
  ctx,
  Number.isFinite(aimDeg) ? aimDeg : NaN,
  windFromDeg,
  windSpeed
);

})();

}


// Animated neon-green target (aim) line so it’s distinct from club colors
if ((tee && target) || (shots.length > 0 && target)) {
  const start = (shots.length > 0) ? shots[shots.length - 1] : tee;

  const hole = parseFloat($('holeYards').value) || 0;
  const R    = parseFloat($('totalYards').value) || 0;
  const teeToPinPix = Math.hypot(pin.x - tee.x, pin.y - tee.y);
  const pxPerYard = (hole > 0) ? (teeToPinPix / hole) : 0;

  // neon green dashed "laser" with subtle glow
  ctx.strokeStyle = '#22ff88';
  ctx.lineWidth = 2.4;
  ctx.setLineDash([4, 3]);
  ctx.lineDashOffset = -targetDashOffset; // <- animated each frame
  ctx.shadowColor = '#22ff88';
  ctx.shadowBlur = 6;

  ctx.beginPath();
  ctx.moveTo(start.x, start.y);
  ctx.lineTo(target.x, target.y);
  ctx.stroke();

  // reset effects for later drawing
  ctx.setLineDash([]);
  ctx.shadowBlur = 0;

  // Yard markers along the planned shot line
  const exAim = unitVec(start, target);
  drawYardMarkers(start, exAim, pxPerYard, R, 10, 50);

  // tell the animation loop a target line was drawn this frame
  hasTargetLine = true;
}



    // tee/pin dots
    if(tee)    drawDot(tee.x, tee.y, '#22c55e', 6);
if(pin)    drawDot(pin.x, pin.y, '#f59e0b', 6);
if(target) drawDot(target.x, target.y, '#38bdf8', 6);


    // shots
  // ---- Preview next shot (faint arc + ghost landing) ----
(function previewNext(){
  if (!tee || !pin) return;

  // Start point = tee for first shot, else last landing
  const start = (shots.length > 0) ? shots[shots.length-1] : tee;

  // Need a target to preview
  if (!target) return;

  // Scale: px per yard from tee→pin vs hole yards
  const hole = parseFloat($('holeYards').value);
  const teeToPinPix = Math.hypot(pin.x-tee.x, pin.y-tee.y);
  if (!Number.isFinite(hole) || hole <= 0) return;
  const pxPerYard = teeToPinPix / hole;

  // Shot length (yards)
  const R = parseFloat($('totalYards').value);
  if (!Number.isFinite(R) || R <= 0) return;

  // Lateral input: finish lateral (m) OR angle (deg)
  const ang = parseFloat($('angleDeg').value);
  const angSide = $('angleSide').value;
  const latM = parseFloat($('finishLatM').value);
  const latSide = $('finishSide').value;

  let theta = Number.isFinite(ang) ? (angSide==='L'? -ang : +ang) : NaN;
  const rad = Number.isFinite(theta) ? theta*Math.PI/180 : NaN;
  const y_from_angle_yd = Number.isFinite(rad) ? (R*Math.sin(rad)) : NaN;

  // Default to original behavior: finish lateral overrides angle if provided
  let y_yd;
  if (Number.isFinite(latM)) {
    y_yd = (latSide==='L' ? -latM : +latM) * (1/0.9144);
  } else if (Number.isFinite(y_from_angle_yd)) {
    y_yd = y_from_angle_yd;
  } else {
    return; // nothing to preview without lateral or angle
  }

  // Guard: lateral cannot exceed shot distance
  const yAbs = Math.abs(y_yd);
  if (yAbs > R) return;

  // Basis from START toward TARGET
  const ex = unitVec(start, target);
  const er = { x: -ex.y, y: ex.x };

  // Arc at distance R around START
  ctx.save();
  ctx.globalAlpha = 0.25;
  ctx.strokeStyle = '#94a3b8';
  ctx.lineWidth = 1;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  ctx.arc(start.x, start.y, R * pxPerYard, 0, Math.PI*2);
  ctx.stroke();
  ctx.restore();

  // Ghost landing point using the same math as calculate()
  const x_yd = Math.sqrt(Math.max(R*R - y_yd*y_yd, 0));
  const xPix = x_yd * pxPerYard;
  const yPix = y_yd * pxPerYard;

  const ghost = {
    x: start.x + ex.x * xPix + er.x * yPix,
    y: start.y + ex.y * xPix + er.y * yPix
  };

  // Ghost path + dot
  ctx.save();
  ctx.globalAlpha = 0.5;
  ctx.strokeStyle = '#a3b2c7';
  ctx.lineWidth = 2;
  ctx.setLineDash([4,4]);
  ctx.beginPath();
  ctx.moveTo(start.x, start.y);
  ctx.lineTo(ghost.x, ghost.y);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.globalAlpha = 0.6;
  drawDot(ghost.x, ghost.y, '#a3b2c7', 5);
  ctx.restore();
})();

// ---- Actual shots (polyline chaining) ----
let p0 = tee; // first segment starts at tee, then chains from last landing
for (const s of shots) {
  if (p0) {
    ctx.strokeStyle = s.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(p0.x, p0.y);
    ctx.lineTo(s.x, s.y);
    ctx.stroke();
  }
  drawDot(s.x, s.y, s.color, 5);
  p0 = s; // next segment starts where this one landed
}


  }

  function drawDot(x,y,color='#ef4444', r=5){
    ctx.fillStyle=color;
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,.35)';
    ctx.stroke();
  }

  function drawArrow(x,y,ang,color='#38bdf8'){
    const L = 10;
    ctx.fillStyle=color;
    ctx.beginPath();
    ctx.moveTo(x,y);
    ctx.lineTo(x - L*Math.cos(ang-0.4), y - L*Math.sin(ang-0.4));
    ctx.lineTo(x - L*Math.cos(ang+0.4), y - L*Math.sin(ang+0.4));
    ctx.closePath();
    ctx.fill();
  }

  function unitVec(a,b){
    const vx = b.x - a.x, vy = b.y - a.y;
    const m = Math.hypot(vx,vy)||1;
    return {x:vx/m, y:vy/m};
  }
// Draw yard markers along a line from `start` in direction `dir` for `yardsTotal`.
function drawYardMarkers(start, dir, pxPerYard, yardsTotal, tickEvery=10, labelEvery=50){
  if(!Number.isFinite(pxPerYard) || pxPerYard <= 0) return;

  const er = { x: -dir.y, y: dir.x }; // perpendicular for tick marks
  ctx.font = '12px system-ui, Segoe UI, Roboto, Arial';
  ctx.textBaseline = 'middle';

  for(let yds = tickEvery; yds <= yardsTotal; yds += tickEvery){
    const isLabel = (yds % labelEvery === 0);
    const tickLen = isLabel ? 10 : 6;
    const x = start.x + dir.x * (yds * pxPerYard);
    const y = start.y + dir.y * (yds * pxPerYard);

    // tick
    ctx.strokeStyle = '#94a3b8';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x - er.x*tickLen/2, y - er.y*tickLen/2);
    ctx.lineTo(x + er.x*tickLen/2, y + er.y*tickLen/2);
    ctx.stroke();

    // label every `labelEvery`
    if(isLabel){
      const tx = x + er.x*14;  // offset from line
      const ty = y + er.y*14;
      // subtle outline for readability
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgba(0,0,0,0.6)';
      ctx.strokeText(`${yds} yd`, tx, ty);
      ctx.fillStyle = '#cbd5e1';
      ctx.fillText(`${yds} yd`, tx, ty);
    }
  }
}
function bearingDeg(ax, ay, bx, by){
  // 0° = North (up), 90° = East (right), clockwise positive
  const dx = bx - ax, dy = by - ay;
  const deg = (Math.atan2(dx, -dy) * 180/Math.PI + 360) % 360;
  return deg;
}

function drawCompassOverlay(ctx, aimBearing, windFromDeg, windSpeed){
  // Draw in screen-space (no zoom/pan)
  ctx.setTransform(1,0,0,1,0,0);

  const size = 90;      // panel inner size
  const pad  = 10;      // margin from top-left
  const r    = 30;      // compass radius
  const x0   = pad + 8; // panel x
  const y0   = pad + 8; // panel y

  // Panel (rounded if supported)
  ctx.fillStyle = 'rgba(10,20,34,0.7)';
  ctx.strokeStyle = 'rgba(36,49,68,0.9)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  if (ctx.roundRect) ctx.roundRect(x0-8, y0-16, size+32, size+34, 10);
  else ctx.rect(x0-8, y0-16, size+32, size+34);
  ctx.fill(); ctx.stroke();

  // Compass ring
  ctx.beginPath();
  ctx.arc(x0 + size/2, y0 + size/2, r, 0, Math.PI*2);
  ctx.strokeStyle = '#e2e8f0';
  ctx.lineWidth = 1;
  ctx.stroke();

  // N label
  ctx.fillStyle = '#e2e8f0';
  ctx.font = '12px system-ui, Segoe UI, Roboto';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('N', x0 + size/2, y0 + size/2 - r - 10);

  // Aim arrow (laser green)
  if (Number.isFinite(aimBearing)){
    const rad = aimBearing * Math.PI/180;
    const cx = x0 + size/2, cy = y0 + size/2;
    const len = r - 6;
    const ex = Math.sin(rad), ey = -Math.cos(rad);
    ctx.strokeStyle = '#22ff88';
    ctx.lineWidth = 2.5;
    ctx.shadowColor = '#22ff88';
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.moveTo(cx - ex*10, cy - ey*10);
    ctx.lineTo(cx + ex*len, cy + ey*len);
    ctx.stroke();
    // arrow head
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#22ff88';
    ctx.beginPath();
    ctx.moveTo(cx + ex*len, cy + ey*len);
    ctx.lineTo(cx + ex*(len-8) + ey*5, cy + ey*(len-8) - ex*5);
    ctx.lineTo(cx + ex*(len-8) - ey*5, cy + ey*(len-8) + ex*5);
    ctx.closePath(); ctx.fill();
  }

  // Wind arrow (FROM → draw TO direction)
  if (Number.isFinite(windFromDeg) && (windSpeed ?? 0) >= 0){
    const toDeg = (windFromDeg + 180) % 360;
    const rad = toDeg * Math.PI/180;
    const cx = x0 + size/2, cy = y0 + size/2;
    const len = r - 14;
    const ex = Math.sin(rad), ey = -Math.cos(rad);
    ctx.strokeStyle = '#7dd3fc';
    ctx.lineWidth = 2;
    ctx.setLineDash([3,3]);
    ctx.beginPath();
    ctx.moveTo(cx - ex*8, cy - ey*8);
    ctx.lineTo(cx + ex*len, cy + ey*len);
    ctx.stroke();
    ctx.setLineDash([]);
    // head
    ctx.fillStyle = '#7dd3fc';
    ctx.beginPath();
    ctx.moveTo(cx + ex*len, cy + ey*len);
    ctx.lineTo(cx + ex*(len-7) + ey*4, cy + ey*(len-7) - ex*4);
    ctx.lineTo(cx + ex*(len-7) - ey*4, cy + ey*(len-7) + ex*4);
    ctx.closePath(); ctx.fill();

      // speed + description text
  ctx.fillStyle = '#a3b2c7';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'alphabetic';
  ctx.fillText(`${windSpeed || 0} mph`, x0 - 2, y0 + size + 6);

  // speed + description text (inline)
let desc = '';
if (windSpeed < 4) desc = 'Calm';
else if (windSpeed < 8) desc = 'Light breeze';
else if (windSpeed < 15) desc = 'Breezy';
else if (windSpeed < 20) desc = 'Windy';
else desc = 'Strong gusts';

ctx.fillStyle = '#a3b2c7';
ctx.textAlign = 'left';
ctx.textBaseline = 'alphabetic';
ctx.font = '12px system-ui, Segoe UI, Roboto';
ctx.fillText(`${windSpeed || 0} mph – ${desc}`, x0 - 2, y0 + size + 6);


  }
}

  // ---------- math & plotting ----------
  $('calcBtn').addEventListener('click', ()=>{
    clearOut();
   if(!tee || !pin || !target){
  line('Click the image to place Tee, then Pin, then Target line point.', 'err');
  return;
}
const hole = parseFloat($('holeYards').value);
// Total shot distance is the player's shot length (can be shorter or longer than hole)
const R = parseFloat($('totalYards').value);


    const ang = parseFloat($('angleDeg').value);
    const angSide = $('angleSide').value;
    const latM = parseFloat($('finishLatM').value);
    const latSide = $('finishSide').value;

    if(!Number.isFinite(hole) || !Number.isFinite(R) || R<=0){
      line('Enter hole distance and total shot distance.', 'err');
      return;
    }

    let theta = Number.isFinite(ang) ? (angSide==='L'? -ang : +ang) : NaN;
    const rad = Number.isFinite(theta) ? theta*Math.PI/180 : NaN;
    const y_from_angle_yd = Number.isFinite(rad) ? (R*Math.sin(rad)) : NaN;

    // Choose final lateral
    let y_yd, usedFinish = false;
    if(Number.isFinite(latM)){
      y_yd = (latSide==='L' ? -latM : +latM) * m2yd;
      usedFinish = true;
    } else if(Number.isFinite(y_from_angle_yd)){
      y_yd = y_from_angle_yd;
    } else {
      line('Enter a launch angle or a finish lateral (meters).', 'err');
      return;
    }

    const yAbs = Math.abs(y_yd);
    if(yAbs > R){
      line(`Lateral (${fmt(yAbs,1)} yd) can’t exceed total distance (${fmt(R,1)} yd).`, 'err');
      return;
    }

    const x_yd = Math.sqrt(Math.max(R*R - y_yd*y_yd, 0));
    const final_angle_deg = (R>0) ? (Math.asin(y_yd/R)*180/Math.PI) : 0;

    // Start from tee for the first shot, otherwise from the last landing
const start = (shots.length > 0)
  ? { x: shots[shots.length-1].x, y: shots[shots.length-1].y }
  : tee;

// Basis from START toward the TARGET point (aim axis)
const ex = unitVec(start, target);
const er = { x: -ex.y, y: ex.x }; // screen-right perpendicular

// Global scale: pixels per yard using tee→pin vs hole yards (constant across shots)
const teeToPinPix = Math.hypot(pin.x-tee.x, pin.y-tee.y);
const pxPerYard = teeToPinPix / hole;

// Landing from START
const xPix = x_yd * pxPerYard;
const yPix = y_yd * pxPerYard;
const land = {
  x: start.x + ex.x * xPix + er.x * yPix,
  y: start.y + ex.y * xPix + er.y * yPix
};


   // Results relative to the pin FROM CURRENT START (not always the tee)
const exT = ex;                 // unit along target (from start)
const erT = er;                 // right of target
const exP = unitVec(start, pin);        // unit along start→pin
const erP = { x: -exP.y, y: exP.x };    // right of start→pin

// dot products between bases
const d_exT_exP = exT.x*exP.x + exT.y*exP.y;
const d_erT_exP = erT.x*exP.x + erT.y*exP.y;
const d_exT_erP = exT.x*erP.x + exT.y*erP.y;
const d_erT_erP = erT.x*erP.x + erT.y*erP.y;

// shot components in the pin-aligned basis
const x_along_pin_yd = x_yd * d_exT_exP + y_yd * d_erT_exP;
const y_rel_pin_yd   = x_yd * d_exT_erP + y_yd * d_erT_erP;

// remaining to pin along start→pin
const startToPinPix = Math.hypot(pin.x - start.x, pin.y - start.y);
const hole_remaining_yd = startToPinPix / pxPerYard;

const dx_to_pin_yd = hole_remaining_yd - x_along_pin_yd; // + short, − long
const dist_to_pin_yd = Math.hypot(dx_to_pin_yd, y_rel_pin_yd);



  // Output (simplified, color-coded, and clearer)
line('Relative to the Pin:', 'pill');

// Distance color: green if ≤10 yd, red if >10 yd
const distColor = dist_to_pin_yd <= 10 ? '#22c55e' : '#ef4444';

line(
  `<div style="
    font-size:1.8em;
    font-weight:800;
    color:${distColor};
    margin:6px 0;
  ">
    ${fmt(dist_to_pin_yd,1)} yd
    <span style="font-size:0.8em;color:#a3b2c7;">
      (${fmt(dist_to_pin_yd*yd2m,1)} m)
    </span>
  </div>`
);

line(
  `Short/Long: <b>${dx_to_pin_yd>=0
    ? fmt(dx_to_pin_yd,1)+' yd short'
    : fmt(-dx_to_pin_yd,1)+' yd long'
  }</b> (${fmt(Math.abs(dx_to_pin_yd)*yd2m,1)} m)`
);

line(
  `Left/Right of pin: <b>${fmt(Math.abs(y_rel_pin_yd),1)} yd ${y_rel_pin_yd<0
    ? 'Left' 
    : y_rel_pin_yd>0
    ? 'Right' 
    : '(online)'
  }</b> (${fmt(Math.abs(y_rel_pin_yd)*yd2m,1)} m)`
);


    // Store & draw shot
const club = ($('clubSelect') && $('clubSelect').value) || '';
const color = getClubGroupColor(club) || shotColors[shotIndex++ % shotColors.length];
shots.push({



  x: land.x,
  y: land.y,
  color,
  club,
  totalYards: R,
  shortLongYd: dx_to_pin_yd,  // +short / −long (relative to pin)
  leftRightYd: y_rel_pin_yd,  // +Right / −Left (relative to pin)
  distToPinYd: dist_to_pin_yd
});
redraw();
renderShotList();
// Next shot: click anywhere to set a new target from this landing point
clickStatus.textContent = 'TARGET';
});

// end IIFE
})();

</script>
</body>
</html>
